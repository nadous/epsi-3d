<!DOCTYPE html>
<html>

<head>
    <title>Interactive Maps - WebGL Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <link rel="stylesheet" type="text/css" href="css/style.css">


    <script src="lib/three.js/three.js"></script>
    <script src="lib/three.js/OrbitControls.js"></script>
    <script src="lib/d3/d3.js"></script>
    <script src="lib/topojson/topojson.js"></script>
    <script src="lib/papaparse/papaparse.js"></script>

</head>

<body>
    <div id="info">
        <h3>Interactive Maps - WebGL Demo</h3>
        <div id="msg">Mouseover a country...</div>
        <div id="data_country"></div>
        <div>Click to rotate the globe</div>
    </div>
    <div id="loading">Loading...</div>
    <script>
        var topology = topojson.topology({
            foo: geojson
        });
    </script>
    <script src="js/refractor/scene.js"></script>
    <script src="js/refractor/setEvents.js"></script>
    <script src="js/refractor/geoHelpers.js"></script>
    <script src="js/refractor/mapTexture.js"></script>
    <script src="js/refractor/utils.js"></script>
    <script>
        var gParsedCountryData;
        var gMin;
        var gMax;

        // utilisé pour regler la caméra
        var controls, cloudMesh, starBackground;

        // Pour papaparse, il est nécéssaire de recharger manuellement la librairie -> https://github.com/mholt/PapaParse/issues/148
        Papa.SCRIPT_PATH = "node_modules/papaparse/papaparse.js";
        // Appel de la fonction de parsing avec callback pour transmettre les données
        parseData("../../data/data_co2.csv", doStuff);



        // On parse les données et on récupère le taux d'emission min et max de l'ensemble des pays
        function parseData(url, callBack) {
            Papa.parse(url, {
                delimiter: ",",
                header: true,
                download: true,
                complete: function(results, file) {
                    var result = [];
                    var min = Number.POSITIVE_INFINITY;
                    var max = Number.NEGATIVE_INFINITY;
                    for (var i = 0; i < results.data.length; i++) {
                        //init
                        var item = results.data[i];
                        var cntryName = item["Country Name"];
                        var data2013 = item["2013"];
                        result[cntryName] = data2013;
                        // Besoin de faire une vérification car certaines données sont absentes
                        if (data2013 != "") {
                            min = Math.min(min, data2013);
                            max = Math.max(max, data2013);
                        }
                    }
                    console.log("valeur mini: ", min);
                    console.log("valeur maxi: ", max);
                    //Appel du callBack et demarrage du programme
                    callBack(result, min, max);
                }
            });
        }

        // Complete le code hexa d'une couleur par des zero
        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        // Transforme un code RGB en hexadecimal
        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }


        // Fonction callback qui execute la quasi totalité du script
        function doStuff(parsedCountryData, minEmissionCntry, maxEmissionCntry) {
            gParsedCountryData = parsedCountryData;
            gMin = minEmissionCntry;
            gMax = maxEmissionCntry;

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;
            controls.enableZoom = false;

            // Chargement de la carte avec les identifiants par pays. A voir à l'intérieur.
            // On remarque qu'on définit des arcs de points pour les pays
            // format: {"type":"MultiPolygon","arcs":[[[6,7,8,9]],[[10,11,12]]],"id":"Angola"}
            d3.json('data/world.json', function(err, data) {

                d3.select("#loading").transition().duration(500)
                    .style("opacity", 0).remove();

                var currentCountry, overlay, overlay2, overlay3, tabOverlay;

                // number of vertices. Higher = better mouse accuracy
                // Vérifié. Passage de 155 en std à 200.
                var segments = 200;

                // Setup cache for country textures
                var countries = topojson.feature(data, data.objects.countries);
                var geo = geodecoder(countries.features);

                // Script embarqué à l'init. A priori pas besoin de le modifier.
                // On va initialiser le cache de la texture lors du mouseOver
                var textureCache = memoize(
                    function(cntryID, color) {
                        var country = geo.find(cntryID);
                        return mapTexture(country, color);
                    }
                );

                // Base globe with blue "water"
                let blueMaterial = new THREE.MeshPhongMaterial({
                    color: '#2B3B59',
                    transparent: true
                });
                let sphere = new THREE.SphereGeometry(200, segments, segments);
                let baseGlobe = new THREE.Mesh(sphere, blueMaterial);
                baseGlobe.rotation.y = Math.PI;
                baseGlobe.addEventListener('click', onGlobeClick);
                baseGlobe.addEventListener('mousemove', onGlobeMousemove);

                // add base map layer with all countries
                // Besoin d'invervention ici. On va appliquer la couleur que l'on désire à chaque country
                let worldTexture = mapTextures(countries, map_number, mapToHex);
                let mapMaterial = new THREE.MeshPhongMaterial({
                    map: worldTexture,
                    transparent: true
                });
                mapMaterial.bumpMap   = THREE.ImageUtils.loadTexture('img/earthbump1k.jpg');
                mapMaterial.bumpScale = 200.3;
                var baseMap = new THREE.Mesh(new THREE.SphereGeometry(200, segments, segments), mapMaterial);
                baseMap.rotation.y = Math.PI;

                let geometry = new THREE.SphereGeometry(200.5, segments, segments);
                let material = new THREE.MeshPhongMaterial({
                    map: THREE.ImageUtils.loadTexture('img/fair_clouds_4k.png'),
                    transparent: true,
                    opacity: 0.8
                });
                cloudMesh = new THREE.Mesh(geometry, material);
                cloudMesh.rotation.y = Math.PI;

                let backgroundGeometry = new THREE.SphereGeometry(400, segments, segments);
                let backgroundMaterial = new THREE.MeshPhongMaterial({
                    map: THREE.ImageUtils.loadTexture('img/starB.png'),
                    transparent: true,
                    side: THREE.DoubleSide
                });

                starBackground = new THREE.Mesh(backgroundGeometry,backgroundMaterial);
                starBackground.rotation.y = Math.PI;

                // create a container node and add the two meshes
                var root = new THREE.Object3D();
                root.scale.set(2.5, 2.5, 2.5);


                root.add(baseGlobe);
                root.add(baseMap);
                root.add(cloudMesh);
                root.add(starBackground);
                scene.add(root);

                function onGlobeClick(event) {
                    // Get pointc, convert to latitude/longitude
                    var latlng = getEventCenter.call(this, event);
                    // on recherche si on a cliquer sur un pays
                    var country = geo.search(latlng[0], latlng[1]);
                    // si on clique sur un pays
                    if (country !== null) {
                        console.log("Pays rencontré -> ", country.code);
                    } else // si on cique en dehors du globe || n'est pas un pays
                    {
                      /*
                        // Get new camera position
                        var temp = new THREE.Mesh();
                        temp.position.copy(convertToXYZ(latlng, 900));
                        console.log(root.position);
                        temp.lookAt(root.position);
                        temp.rotateY(Math.PI);

                        for (let key in temp.rotation) {
                            if (temp.rotation[key] - camera.rotation[key] > Math.PI) {
                                temp.rotation[key] -= Math.PI * 2;
                            } else if (camera.rotation[key] - temp.rotation[key] > Math.PI) {
                                temp.rotation[key] += Math.PI * 2;
                            }
                        }

                        var tweenPos = getTween.call(camera, 'position', temp.position);
                        d3.timer(tweenPos);

                        var tweenRot = getTween.call(camera, 'rotation', temp.rotation);
                        d3.timer(tweenRot);
                        */
                    }
                }

                function onGlobeMousemove(event) {
                    var map, material;

                    // Get pointc, convert to latitude/longitude
                    var latlng = getEventCenter.call(this, event);

                    // Look for country at that latitude/longitude
                    var country = geo.search(latlng[0], latlng[1]);

                    if (country !== null && country.code !== currentCountry) {

                        // Track the current country displayed
                        currentCountry = country.code;

                        // Update the html
                        d3.select("#msg").html(country.code);
                        d3.select("#data_country").html("CO² emissions (kt) " + gParsedCountryData[country.code]);

                        // Overlay the selected country
                        //Il faut ici modifier la couleur lors de l'overlay
                        var hexaColor = mapToHex(country.code);
                        map = textureCache(country.code, hexaColor);
                        material = new THREE.MeshPhongMaterial({
                            map: map,
                            transparent: true
                        });
                        if (!tabOverlay) {
                            tabOverlay = [];
                            for (var i = 0; i < 10; i++) {
                                tabOverlay[i] = new THREE.Mesh(new THREE.SphereGeometry(201 + i, 40, 40), material);
                                tabOverlay[i].rotation.y = Math.PI;
                                root.add(tabOverlay[i]);
                            }
                        } else {
                            for (var i = 0; i < 10; i++) {
                                tabOverlay[i].material = material;
                            }
                        }
                    }
                }
                setEvents(camera, [baseGlobe], 'click');
                setEvents(camera, [baseGlobe], 'mousemove', 10);
            });

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                if (typeof cloudMesh !== 'undefined' &&  typeof cloudMesh.rotation !== 'undefined' && typeof cloudMesh.rotation.y !== 'undefined'){
                    cloudMesh.rotation.y += 0.0005;
                }
                renderer.render(scene, camera);
            }

            function map_number(n, in_min, in_max, out_min, out_max) {
                return (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
            }

            function mapToHex(countryId) {
                var countrySelected = countryId;
                var valueCountry = gParsedCountryData[countrySelected];
                var hexaColor = '#ffffff';
                if (typeof valueCountry != 'undefined') {
                    var co2_factor = valueCountry / gMax;
                    if (co2_factor > .75) {
                        hexaColor = rgbToHex(75, 0, 0);
                    } else if (co2_factor > .5) {
                        var variation = map_number(co2_factor, .5, .75, 100, 75);
                        hexaColor = rgbToHex(Math.round(variation), 0, 0);
                    } else if (co2_factor > .25) {
                        var variation = map_number(co2_factor, .5, .75, 180, 100);
                        hexaColor = rgbToHex(Math.round(variation), 0, 0);
                    } else if (co2_factor > .1) {
                        var variation = map_number(co2_factor, 0, .25, 30, 0);
                        hexaColor = rgbToHex(255, Math.round(variation), Math.round(variation));
                    } else if (co2_factor > .01) {
                        var variation = map_number(co2_factor, 0, .25, 100, 30);
                        hexaColor = rgbToHex(255, Math.round(variation), Math.round(variation));
                    } else if (co2_factor > 0) {
                        hexaColor = rgbToHex(0, 255, 0);
                    } else //pas de valeur
                    {
                        hexaColor = rgbToHex(255, 255, 255);
                    }
                }
                return hexaColor;
            }

            animate();
        }
    </script>
</body>

</html>
