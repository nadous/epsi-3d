<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title> Maze </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="JS/three.js-master/build/three.js"></script>
    <!--<script src="JS/three.js-master/examples/js/controls/OrbitControls.js"></script>-->

    <script src="JS/physi.js"></script>

    <script type="text/javascript">
        /*
         * Configuration des dépendances
         */
        Physijs.scripts.worker = 'JS/physijs_worker.js';
        Physijs.scripts.ammo = 'ammo.js';

        let renderer, scene, camera, moveX = 0, moveZ = 0;
        let ball, board;

        /*
         * Taille des éléments
         */
        const part_size = 50; // taille des dalles
        const board_height = 5; // hauteur du plateau
        const wall_height = 75; // hauteur des murs
        const camera_height = 600;


        /*
         * Le labyrinthe
         */
        const level = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        function init() {
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene = new Physijs.Scene({
                fixedTimeStep: 1 / 120
            });
            scene.setGravity(new THREE.Vector3(0, -250, 0));



            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, camera_height, 0);

            /*controls = new THREE.OrbitControls(camera);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;*/

            document.getElementById('container').appendChild(renderer.domElement);
            document.addEventListener( 'keydown', onKeyDown, false ); // listen to keyboard inputs
            init_maze();
        }

        /*
         * Detect user inputs
         */
        function onKeyDown ( event ) {
            var moveDistanceX = 0.01; // player speed
            var moveDistanceZ = 0.01;

            switch ( event.keyCode )
            {
                case 37: // left arrow
                    moveZ = moveDistanceZ;
                    break;
                case 38: // up arrow
                    moveX = moveDistanceX;
                    break;
                case 39: // right arrow
                    moveZ = moveDistanceZ;
                    break;
                case 40: // down arrow
                    moveX = moveDistanceX;
                    break;
            }

            console.log(moveX, moveZ);

        }



        // function pour créer les cube (mur) et les trous qui seront répété n fois
        function init_maze() {
            const light = new THREE.DirectionalLight(0xFFFFFF);
            light.position.set(40, 40, 0);
            light.target.position.copy(scene.position);
            light.castShadow = true;
            light.shadow.camera.left = -60;
            light.shadow.camera.top = -60;
            light.shadow.camera.right = 60;
            light.shadow.camera.bottom = 60;
            light.shadow.camera.near = 20;
            light.shadow.camera.far = 200;
            light.shadow.bias = -.0001
            light.shadow.mapSize.widht = light.shadow.mapSize.height = 2048;
            light.shadow.darkness = .7;
            scene.add(light);

            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xff0000
            }), .4, .6);
            board = new Physijs.BoxMesh(
                new THREE.CubeGeometry(50, 1, 50),
                material, 0);

            // What is it?
            board.__dirtyPosition = true;
            board.position.y = -40;


            ball = new Physijs.SphereMesh(
                new THREE.SphereGeometry(10, 16, 16),
                material,
                20 // la masse
            );

            ball.position.x = -260;
            ball.position.y = 60;
            ball.position.z = -320;

            for (let i = 0; i < level.length; i++) {
                for (let j = 0; j < level[i].length; j++) {
                    const x = map_number(i, 0, level.length, -level.length * .5, level.length * .5);
                    const y = map_number(j, 0, level[i].length, -level[i].length * .5, level[i].length * .5);
                    switch (level[i][j]) {
                        case 0:
                            addBoardPart(x, y, level.length, level[i].length);
                            break;
                        case 1:
                            addWall(x, y, level.length, level[i].length);
                            break;
                        case 3:
                            addFinish(x, y, level.length, level[i].length);
                            break;
                    }
                }
            }

            scene.add(board);
            scene.add(ball);

            render();
        }

        // creation du plan
        function addBoardPart(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xffffff
            }), .4, .6);

            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, board_height, part_size),
                material, 0);

            cube.receiveShadow = true;
            cube.castShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;



            board.add(cube);
        }

        // creation du mur qui nous fait gagner
        function addFinish(x, z, rows, cols) {
            addBoardPart(x, z, rows, cols);

            const material = new THREE.MeshLambertMaterial({
                color: 0xff0000,
            });
            const finish = new Physijs.SphereMesh(
                new THREE.SphereGeometry(10, 16, 16),
                material, 0);

            finish.position.x = x * part_size;
            finish.position.y = -40;
            finish.position.z = z * part_size;

            finish.addEventListener('collision', function(object) {
                alert('You win!');
            });

            scene.add(finish);
        }

        // creation de trou pour faire perdre le joueur
        function addWall(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff
            }), .4, .6);
            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, wall_height, part_size),
                material, 0);

            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;

            board.add(cube);
        }

        function render() {
            requestAnimationFrame(render);

            scene.simulate();
            /*controls.update();*/
            camera.position.set(ball.position.x -20,camera_height,ball.position.z - 20);
            camera.lookAt(ball.position);
            renderer.render(scene, camera);


            board.rotation.x += 0.01;
            board.rotation.z += 0.01;

        }

        function map_number(n, in_min, in_max, out_min, out_max) {
            return (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
    </script>
</head>

<body>
    <div id="container"></div>
</body>

</html>
