<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title> Maze </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="../../three.js-master/build/three.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>

    <script src="../../Physijs/physi.js"></script>

    <script type="text/javascript">
        Physijs.scripts.worker = '../../Physijs/physijs_worker.js';
        Physijs.scripts.ammo = './../Physijs/examples/js/ammo.js';

        let renderer, scene, camera;
        let ball, board;

        const part_size = 50;
        const board_height = 5;
        const wall_height = 75;

        const level = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        function init() {
            // on initialise le moteur de rendu
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // on initialise la scène
            scene = new Physijs.Scene({
                fixedTimeStep: 1 / 120
            });
            scene.setGravity(new THREE.Vector3(20, -120, -30));
            // scene.fog = new THREE.FogExp2(0xffffff, 0.075);

            // on initialise la camera que l’on place ensuite sur la scène
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 100, 200);
            camera.lookAt(new THREE.Vector3());

            controls = new THREE.OrbitControls(camera);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;

            document.getElementById('container').appendChild(renderer.domElement);

            init_maze();
        }

        // function pour créer les cube (mur) et les trous qui seront répété n fois
        function init_maze() {
            // Light
            const light = new THREE.DirectionalLight(0xFFFFFF);
            light.position.set(40, 40, 0);
            light.target.position.copy(scene.position);
            light.castShadow = true;
            light.shadow.camera.left = -60;
            light.shadow.camera.top = -60;
            light.shadow.camera.right = 60;
            light.shadow.camera.bottom = 60;
            light.shadow.camera.near = 20;
            light.shadow.camera.far = 200;
            light.shadow.bias = -.0001
            light.shadow.mapSize.widht = light.shadow.mapSize.height = 2048;
            light.shadow.darkness = .7;
            scene.add(light);

            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xff0000,
                // wireframe: true
            }), .4, .6);
            const ground_geometry = new THREE.CubeGeometry(50, 1, 50);
            board = new Physijs.BoxMesh(ground_geometry, material, 0);
            // What is it?
            board.__dirtyPosition = true;
            board.position.y = -40;

            ball = new Physijs.SphereMesh(
                new THREE.SphereGeometry(10, 16, 16),
                material,
                20, {
                    restitution: 3
                }
            );

            ball.position.y = 60;
            ball.position.x = 25;

            for (let i = 0; i < level.length; i++) {
                for (let j = 0; j < level[i].length; j++) {
                    const x = map_number(i, 0, level.length, -level.length * .5, level.length * .5);
                    const y = map_number(j, 0, level[i].length, -level[i].length * .5, level[i].length * .5);
                    switch (level[i][j]) {
                        case 0:
                            addBoardPart(x, y, level.length, level[i].length);
                            break;
                        case 1:
                            addWall(x, y, level.length, level[i].length);
                            break;
                        case 3:
                            addFinish(x, y, level.length, level[i].length);
                            break;
                    }
                }
            }

            scene.add(board);
            scene.add(ball);

            render();
        }
        // creation du plan
        function addBoardPart(x, z, rows, cols) {
            const geometry = new THREE.CubeGeometry(part_size, board_height, part_size);
            const boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xffffff,
                // wireframe: true
            }), .4, .6);
            const cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;
            cube.receiveShadow = true;
            cube.castShadow = true;

            board.add(cube);
        }

        // creation du mur qui nous fait gagner
        function addFinish(x, z, rows, cols) {
            addBoardPart(x, z, rows, cols);
            const finishMaterial = new THREE.MeshLambertMaterial({
                color: 0xff0000,
                // wireframe: true
            });
            const finish = new Physijs.SphereMesh(
              new THREE.SphereGeometry(10, 16, 16),
              finishMaterial, 0);
              
            finish.position.x = x * part_size;
            finish.position.y = 0
            finish.position.z = z * part_size;

            finish.addEventListener('collision', function(object) {
                alert('You win!');
            });
            scene.add(finish);
        }

        // creation de trou pour faire perdre le joueur
        function addWall(x, z, rows, cols) {
            var geometry = new THREE.CubeGeometry(part_size, wall_height, part_size);
            var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff,
                // wireframe: true
            }), .4, .6);
            var cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;
            cube.receiveShadow = true;
            cube.castShadow = true;

            board.add(cube);
        }

        function render() {
            requestAnimationFrame(render);

            scene.simulate();
            controls.update();
            renderer.render(scene, camera);
        }

        function map_number(n, in_min, in_max, out_min, out_max) {
            return (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
    </script>
</head>

<body>
    <div id="container"></div>
</body>

</html>
