<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title> Maze </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="../../three.js-master/build/three.min.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>
    <script src="../../three.js-master/examples/js/libs/stats.min.js"></script>
    <script src="../../Physijs-master/physi.js"></script>


    <script type="text/javascript">
        /*
         * Configuration des dépendances
         */
        Physijs.scripts.worker = '../../Physijs-master/physijs_worker.js';
        Physijs.scripts.ammo = './../Physijs-master/ammo.js';

        let renderer, scene, camera, controls, stats;
        let moveX = 0,
            moveZ = 0;
        let ball, board, finish;


        /*
         * Taille des éléments
         */
        const part_size = 50; // taille des dalles
<<<<<<< HEAD
        const board_height = 5; // hauteur du plateau
        const wall_height = 75; // hauteur des murs
        const camera_height = 800;
=======
        const board_height = 10; // hauteur du plateau
        const wall_height = 50; // hauteur des murs
        const camera_height = 600;
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86
        const board_rotation = new THREE.Vector3();
        const key_influence = .01;
        /*
         * Le labyrinthe
         */
        const level = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        function init() {

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene = new Physijs.Scene();
            scene.setGravity(new THREE.Vector3(0, -1000, 0));

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, camera_height, 0);

            controls = new THREE.OrbitControls(camera);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;
            controls.enablePan = false;

            // SKYBOX/FOG
            var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
            var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
            var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
            scene.add(skyBox);

            document.getElementById('container').appendChild(renderer.domElement);
            document.addEventListener('keydown', onKeyDown, false); // listen to keyboard inputs

            init_maze();
        }

        // function pour créer les cube (mur) et les trous qui seront répété n fois
        function init_maze() {
            const light = new THREE.DirectionalLight(0xFFFFFF);
            light.position.set(40, 40, 0);
            light.target.position.copy(scene.position);
            light.castShadow = true;
            light.shadow.camera.left = -60;
            light.shadow.camera.top = -60;
            light.shadow.camera.right = 60;
            light.shadow.camera.bottom = 60;
            light.shadow.camera.near = 20;
            light.shadow.camera.far = 200;
            light.shadow.bias = -.0001
            light.shadow.mapSize.widht = light.shadow.mapSize.height = 2048;
            light.shadow.darkness = .7;
            scene.add(light);


            stats = new Stats();
            container.appendChild(stats.dom);
            scene.add(stats);

            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xff0000
            }), .4, .6);
            board = new Physijs.BoxMesh(
                new THREE.CubeGeometry(50, 1, 50),
                material, 0);

            board.position.y = 0;
            board.__dirtyPosition = true;

            ball = new Physijs.SphereMesh(
                new THREE.SphereGeometry(12, 20, 20),
                material,
                200 // la masse
            );

<<<<<<< HEAD
            ball.position.x = 265;
            ball.position.y = 60;
            ball.position.z = -70;
=======
            ball.position.x = -260;
            ball.position.y = 300;
            ball.position.z = -320;
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86

            for (let i = 0; i < level.length; i++) {
                for (let j = 0; j < level[i].length; j++) {
                    const x = map_number(i, 0, level.length, -level.length * .5, level.length * .5);
                    const y = map_number(j, 0, level[i].length, -level[i].length * .5, level[i].length * .5);
                    switch (level[i][j]) {
                        case 0:
                            addBoardPart(x, y, level.length, level[i].length);
                            break;
                        case 1:
                            addWall(x, y, level.length, level[i].length);
                            break;
                        case 3:
                            addFinish(x, y, level.length, level[i].length);
                            break;
                    }
                }
            }
            scene.add(board);
            scene.add(ball);

<<<<<<< HEAD



=======
            scene.simulate();
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86
            render();
        }



        function distanceVector( v1, v2 )
        {
            var dx = v1.x - v2.x;
            var dy = v1.y - v2.y;
            var dz = v1.z - v2.z;

            return Math.sqrt( dx * dx + dy * dy + dz * dz );
        }
/*
        x
                :
                238.2584228515625

        z
                :
                -61.61924743652344



        x
                :
                225

        z
                :
                -75*/
        // creation du plan
        function addBoardPart(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xffffff
            }), .2, .2);

            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, board_height, part_size),
                material, 0);

            cube.receiveShadow = true;
            cube.castShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;

            board.add(cube);
        }

        // creation du mur qui nous fait gagner
        function addFinish(x, z, rows, cols) {
            addBoardPart(x, z, rows, cols);

            const material = new THREE.MeshLambertMaterial({
                color: 0xff0000,
            });
            finish = new Physijs.SphereMesh(
                new THREE.SphereGeometry(10, 16, 16),
                material, 0);

            finish.position.x = x * part_size;
            finish.position.y = 10;
            finish.position.z = z * part_size;

/*            finish.addEventListener('collision', function(object) {
                alert('You win!');
            });*/
            board.add(finish);
        }


        // creation de trou pour faire perdre le joueur
        function addWall(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff
            }), .4, .6);
            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, wall_height, part_size),
                material, 0);

            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.x = x * part_size;
<<<<<<< HEAD
            cube.position.y = (wall_height - board_height)* .5;
=======
            cube.position.y = (wall_height - board_height) * .5;
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86
            cube.position.z = z * part_size;

            board.add(cube);
        }


        /*
         * Detect user inputs
         */
        function onKeyDown(event) {
            switch (event.keyCode) {
                case 37: // left arrow
                    board_rotation.z += key_influence;
                    break;
                case 38: // up arrow
                    board_rotation.x -= key_influence;
                    break;
                case 39:
                    board_rotation.z -= key_influence; // right arrow
                    break;
                case 40: // down arrow
                    board_rotation.x += key_influence;
                    break;
            }
        }

        function render() {
            requestAnimationFrame(render);
<<<<<<< HEAD
            var dist = distanceVector(ball.position, finish.position);
            if(dist <= 22)
            {
                window.alert("you win");
            }


            const current_rotation = board.rotation.clone();
=======
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86

            if (board_rotation.length() > .000001) {
                const current_rotation = board.rotation.clone();

                current_rotation.x += board_rotation.x;
                current_rotation.y += board_rotation.y;
                current_rotation.z += board_rotation.z;

                board_rotation.multiplyScalar(.9);

                board.rotation.set(current_rotation.x, 0, current_rotation.z);
                board.__dirtyRotation = true;

                board.setLinearVelocity(new THREE.Vector3());
                board.setAngularVelocity(new THREE.Vector3());
            }

<<<<<<< HEAD


/*            if (ball.position.y <= -20) {
                alert('You loose');
                ball = null;
                setTimeout('',5000);
                init()
            }*/

            scene.simulate(undefined, 1);
=======
            scene.simulate(undefined, 2);
>>>>>>> f9fc48863656f038e90e65dab44e6d9ba3768b86
            controls.update();
            stats.update();
            renderer.render(scene, camera);
        }

        function map_number(n, in_min, in_max, out_min, out_max) {
            return (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
    </script>
</head>

<body>
    <div id="container"></div>
</body>

</html>
