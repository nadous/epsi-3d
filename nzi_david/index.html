<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>test tree js</title>

</head>
<body>
<div id="container"></div>

<script src="JS/three.min.js"></script>
<script src="JS/jquery.js"></script>
<script src="JS/physi.js"></script>

<script type="text/javascript">
    var renderer, scene, camera, mesh, board;
    var i = 0;
    var speed = 0.1;
    var oscillationFactor = 10;
    var clock = new THREE.Clock();
    var walltexture, walltexture2;

    init();
    //animate();
    function init(){
        render();
    }
    Physijs.scripts.worker = 'physijs_worker.js';
    function render(){
        const WIDTH = 400;
        const HEIGHT = 300;

        // on initialise le moteur de rendu

        renderer = new THREE.WebGLRenderer(antialias = true);

        // si WebGL ne fonctionne pas :
        // renderer = new THREE.CanvasRenderer();

        renderer.setSize( window.innerWidth, window.innerHeight );
        document.getElementById('container').appendChild(renderer.domElement);

        // on initialise la scène
        var scene = new Physijs.Scene;
        scene.fog = new THREE.FogExp2(0xffffff, 0.075);
        // on initialise la camera que l’on place ensuite sur la scène
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 100 );
        camera.position.set(0, 0, 100);
        scene.add(camera);

        // on créé un  cube au quel on définie un matériau puis on l’ajoute à la scène

        /*var geometry = new THREE.CubeGeometry( 200, 200, 200 );
        var material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );*/


        // on effectue le rendu de la scène

        renderer.render( scene, camera );

        // on créé la sphère

/*        var geometry = new THREE.SphereGeometry( 20, 32, 32 );
        var material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: false });
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );*/




        // on ajoute une lumière blanche
        var lumiere = new THREE.DirectionalLight( 0xffffff, 1.0 );
        lumiere.position.set( 0, 0, 400 );
        scene.add( lumiere );

        addGround(scene);

    }

    /*function animate(){
        requestAnimationFrame( animate );
        mesh.rotation.x += 0.01;
        mesh.rotation.y += 0.02;

        mesh.position.setX(Math.sin(i) * oscillationFactor);
        i+=speed;
        renderer.render( scene, camera );
    }*/

    // function pour créer les cube (mur) et les trous qui seront répété n fois
    function addGround(scene) {
        var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({ color: 0x0000ff }), .4, .6);
        var level = Level1();
        var ground_geometry = new THREE.CubeGeometry(50, 1, 50);
        board = new Physijs.BoxMesh(
                ground_geometry,
                boardMaterial,
                0 );

        board.__dirtyPosition = true;
        board.position.y = -40;

        for (var i = 0; i < level.length; i++) {
            for (var j = 0; j < level[i].length; j++) {
                switch (level[i][j]) {
                    case 0:
                        addBoardPart(i, j, level.length, level[i].length, scene);
                        break;
                    case 1:
                        addWall(i, j, level.length, level[i].length, scene);
                        //addBoardPart(i, j, level.length, level[i].length, scene);
                        break;
                    case 2:
                        //no holes :)
                        addBoardPart(i, j, level.length, level[i].length, scene);
                        //addHole(i, j, level.length, level[i].length, scene);
                        break;
                    case 3:
                        addFinish(i, j, level.length, level[i].length, scene);
                        break;
                }
            }
        }
        scene.add(board);
    }
    // creation du plan
    function addBoardPart(x, z, rows, cols, scene) {
        var geometry = new THREE.CubeGeometry(50, 5, 50);
        var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({ color: 0x000000 }), .4, .6);
        var cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
        cube.position.y = 0;
        cube.position.x = x * 50;
        cube.position.z = z * 50;
        board.add(cube);
    }

    // creation du mur qui nous fait gagner
    function addFinish(x, z, rows, cols, scene) {
        addBoardPart(x, z, rows, cols);
        var finishMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        var geometry = new THREE.SphereGeometry(10, 32, 32);
        var finish = new Physijs.SphereMesh(geometry, finishMaterial, 0);
        finish.position.z = z *  50;
        finish.position.x = x * 50;
        finish.position.y = 5;

        finish.addEventListener('collision', function (object) {
            alert('You win!');
        });
        scene.add(finish);
    }

    // creation de trou pour faire perdre le joueur
    function addWall(x, z, rows, cols, scene) {
        var geometry = new THREE.CubeGeometry(50, 250, 50);
        var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({ color: 0x0000ff }), .4, .6);
        var cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
        cube.position.y = 0;
        cube.position.x = x * 50;
        cube.position.z = z * 50;
        board.add(cube);
    }

    // ajout des trou sur le plan
/*    function addHole(x, y, rows, cols, scene) {
        //add nothing :)
    }*/
    // creation du level
    function Level1() {
        return [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ]
    }

</script>
</body>
</html>