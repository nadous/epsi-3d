<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>test tree js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script src="../../three.js-master/build/three.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>
    
    <script src="../../Physijs/physi.js"></script>

    <script type="text/javascript">
        Physijs.scripts.worker = '../../Physijs/physijs_worker.js';
        Physijs.scripts.ammo = './../Physijs/examples/js/ammo.js';

        var renderer, scene, camera, mesh, board;
        var clock = new THREE.Clock();
        var walltexture, walltexture2;

        init();

        function init() {
            // on initialise le moteur de rendu
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });

            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // on initialise la scène
            scene = new Physijs.Scene;
            scene.fog = new THREE.FogExp2(0xffffff, 0.075);

            // on initialise la camera que l’on place ensuite sur la scène
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 0, 200);

            controls = new THREE.OrbitControls(camera);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;

            // on ajoute une lumière blanche
            var lumiere = new THREE.DirectionalLight(0xffffff, 1.0);
            lumiere.position.set(0, 0, 400);
            scene.add(lumiere);

            addGround(scene);
            render();
        }

        function render() {
            requestAnimationFrame(render);

            controls.update();
            renderer.render(scene, camera);
        }

        // function pour créer les cube (mur) et les trous qui seront répété n fois
        function addGround(scene) {
            var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff
            }), .4, .6);
            var level = Level1();
            var ground_geometry = new THREE.CubeGeometry(50, 1, 50);
            board = new Physijs.BoxMesh(
                ground_geometry,
                boardMaterial,
                0);

            board.__dirtyPosition = true;
            board.position.y = -40;

            for (var i = 0; i < level.length; i++) {
                for (var j = 0; j < level[i].length; j++) {
                    switch (level[i][j]) {
                        case 0:
                            addBoardPart(i, j, level.length, level[i].length, scene);
                            break;
                        case 1:
                            addWall(i, j, level.length, level[i].length, scene);
                            //addBoardPart(i, j, level.length, level[i].length, scene);
                            break;
                        case 2:
                            //no holes :)
                            addBoardPart(i, j, level.length, level[i].length, scene);
                            //addHole(i, j, level.length, level[i].length, scene);
                            break;
                        case 3:
                            addFinish(i, j, level.length, level[i].length, scene);
                            break;
                    }
                }
            }
            scene.add(board);
        }
        // creation du plan
        function addBoardPart(x, z, rows, cols, scene) {
            var geometry = new THREE.CubeGeometry(50, 5, 50);
            var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x000000
            }), .4, .6);
            var cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
            cube.position.y = 0;
            cube.position.x = x * 50;
            cube.position.z = z * 50;
            board.add(cube);
        }

        // creation du mur qui nous fait gagner
        function addFinish(x, z, rows, cols, scene) {
            addBoardPart(x, z, rows, cols);
            var finishMaterial = new THREE.MeshLambertMaterial({
                color: 0xff0000
            });
            var geometry = new THREE.SphereGeometry(10, 32, 32);
            var finish = new Physijs.SphereMesh(geometry, finishMaterial, 0);
            finish.position.z = z * 50;
            finish.position.x = x * 50;
            finish.position.y = 5;

            finish.addEventListener('collision', function(object) {
                alert('You win!');
            });
            scene.add(finish);
        }

        // creation de trou pour faire perdre le joueur
        function addWall(x, z, rows, cols, scene) {
            var geometry = new THREE.CubeGeometry(50, 250, 50);
            var boardMaterial = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff
            }), .4, .6);
            var cube = new Physijs.BoxMesh(geometry, boardMaterial, 0);
            cube.position.y = 0;
            cube.position.x = x * 50;
            cube.position.z = z * 50;
            board.add(cube);
        }

        // ajout des trou sur le plan
        /*    function addHole(x, y, rows, cols, scene) {
                //add nothing :)
            }*/
        // creation du level
        function Level1() {
            return [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
                [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
                [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
                [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
                [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
                [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
                [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        }
    </script>
</body>

</html>
