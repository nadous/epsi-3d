<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title> Maze </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="../../three.js-master/build/three.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>

    <script src="../../Physijs/physi.js"></script>

    <script type="text/javascript">
        /*
         * Configuration des dépendances
         */
        Physijs.scripts.worker = '../../Physijs/physijs_worker.js';
        Physijs.scripts.ammo = './../Physijs/examples/js/ammo.js';

        let renderer, scene, camera, controls;
        let moveX = 0,
            moveZ = 0;
        let ball, board;

        /*
         * Taille des éléments
         */
        const part_size = 50; // taille des dalles
        const board_height = 10; // hauteur du plateau
        const wall_height = 50; // hauteur des murs
        const camera_height = 600;
        const board_rotation = new THREE.Vector3();
        const key_influence = .01;
        /*
         * Le labyrinthe
         */
        const level = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1],
            [1, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 2, 0, 0, 0, 1],
            [1, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 2, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        function init() {
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene = new Physijs.Scene();
            scene.setGravity(new THREE.Vector3(0, -1000, 0));

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, camera_height, 0);

            controls = new THREE.OrbitControls(camera);
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;
            controls.enablePan = false;

            document.getElementById('container').appendChild(renderer.domElement);
            document.addEventListener('keydown', onKeyDown, false); // listen to keyboard inputs

            init_maze();
        }

        // function pour créer les cube (mur) et les trous qui seront répété n fois
        function init_maze() {
            const light = new THREE.DirectionalLight(0xFFFFFF);
            light.position.set(40, 40, 0);
            light.target.position.copy(scene.position);
            light.castShadow = true;
            light.shadow.camera.left = -60;
            light.shadow.camera.top = -60;
            light.shadow.camera.right = 60;
            light.shadow.camera.bottom = 60;
            light.shadow.camera.near = 20;
            light.shadow.camera.far = 200;
            light.shadow.bias = -.0001
            light.shadow.mapSize.widht = light.shadow.mapSize.height = 2048;
            light.shadow.darkness = .7;
            scene.add(light);

            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xff0000
            }), .4, .6);
            board = new Physijs.BoxMesh(
                new THREE.CubeGeometry(50, 1, 50),
                material, 0);

            board.position.y = 0;
            board.__dirtyPosition = true;

            ball = new Physijs.SphereMesh(
                new THREE.SphereGeometry(18, 32, 32),
                material,
                200 // la masse
            );

            ball.position.x = -260;
            ball.position.y = 300;
            ball.position.z = -320;

            for (let i = 0; i < level.length; i++) {
                for (let j = 0; j < level[i].length; j++) {
                    const x = map_number(i, 0, level.length, -level.length * .5, level.length * .5);
                    const y = map_number(j, 0, level[i].length, -level[i].length * .5, level[i].length * .5);
                    switch (level[i][j]) {
                        case 0:
                            addBoardPart(x, y, level.length, level[i].length);
                            break;
                        case 1:
                            addWall(x, y, level.length, level[i].length);
                            break;
                        case 3:
                            addFinish(x, y, level.length, level[i].length);
                            break;
                    }
                }
            }
            scene.add(board);
            scene.add(ball);

            scene.simulate();
            render();
        }

        // creation du plan
        function addBoardPart(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0xffffff
            }), .2, .2);

            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, board_height, part_size),
                material, 0);

            cube.receiveShadow = true;
            cube.castShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = 0;
            cube.position.z = z * part_size;

            board.add(cube);
        }

        // creation du mur qui nous fait gagner
        function addFinish(x, z, rows, cols) {
            addBoardPart(x, z, rows, cols);

            const material = new THREE.MeshLambertMaterial({
                color: 0xff0000,
            });
            const finish = new Physijs.SphereMesh(
                new THREE.SphereGeometry(10, 16, 16),
                material, 0);

            finish.position.x = x * part_size;
            finish.position.y = 0;
            finish.position.z = z * part_size;

            finish.addEventListener('collision', function(object) {
                alert('You win!');
            });

            board.add(finish);
        }

        // creation de trou pour faire perdre le joueur
        function addWall(x, z, rows, cols) {
            const material = Physijs.createMaterial(new THREE.MeshLambertMaterial({
                color: 0x0000ff
            }), .4, .6);
            const cube = new Physijs.BoxMesh(
                new THREE.CubeGeometry(part_size, wall_height, part_size),
                material, 0);

            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.x = x * part_size;
            cube.position.y = (wall_height - board_height) * .5;
            cube.position.z = z * part_size;

            board.add(cube);
        }

        /*
         * Detect user inputs
         */
        function onKeyDown(event) {
            switch (event.keyCode) {
                case 37: // left arrow
                    board_rotation.z += key_influence;
                    break;
                case 38: // up arrow
                    board_rotation.x -= key_influence;
                    break;
                case 39:
                    board_rotation.z -= key_influence; // right arrow
                    break;
                case 40: // down arrow
                    board_rotation.x += key_influence;
                    break;
            }
        }

        function render() {
            requestAnimationFrame(render);

            if (board_rotation.length() > .000001) {
                const current_rotation = board.rotation.clone();

                current_rotation.x += board_rotation.x;
                current_rotation.y += board_rotation.y;
                current_rotation.z += board_rotation.z;

                board_rotation.multiplyScalar(.9);

                board.rotation.set(current_rotation.x, 0, current_rotation.z);
                board.__dirtyRotation = true;

                board.setLinearVelocity(new THREE.Vector3());
                board.setAngularVelocity(new THREE.Vector3());
            }

            scene.simulate(undefined, 2);
            controls.update();
            renderer.render(scene, camera);
        }

        function map_number(n, in_min, in_max, out_min, out_max) {
            return (n - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
    </script>
</head>

<body>
    <div id="container"></div>
</body>

</html>
