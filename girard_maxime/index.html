<html lang="en">

<head>
    <title> INTRO </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <style>
        body {
            background-color: #193c6d;
            filter: progid: DXImageTransform.Microsoft.gradient(gradientType=1, startColorstr='#003073', endColorstr='#029797');
            background-image: url(//img.alicdn.com/tps/TB1d.u8MXXXXXXuXFXXXXXXXXXX-1900-790.jpg);
            background-size: 100%;
            background-image: -webkit-gradient(linear, 0 0, 100% 100%, color-stop(0, #003073), color-stop(100%, #029797));
            background-image: -webkit-linear-gradient(135deg, #003073, #029797);
            background-image: -moz-linear-gradient(45deg, #003073, #029797);
            background-image: -ms-linear-gradient(45deg, #003073 0, #029797 100%);
            background-image: -o-linear-gradient(45deg, #003073, #029797);
            background-image: linear-gradient(135deg, #003073, #029797);
            text-align: center;
            margin: 0px;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>

    <script src="js/three.js"></script>
    <script src="js/datGui.js"></script>
    <script src="js/jquery.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/Projector.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/CanvasRenderer.js"></script>
<script>
        var container, stats;

        var camera, scene, renderer, controls;

        var group;

        var targetRotation = 0;
        var targetRotationOnMouseDown = 0;

        var mouseX = 0;
        var mouseXOnMouseDown = 0;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;
        var numberOfGroup = 0;

        var loader = new THREE.FontLoader();
        loader.load( 'fonts/exo.json', function ( font ) {

            init( font );
            animate();

        } );
        

        function init( font ) {

            var FizzyText = function() {
                this.word = 'Bad';
                this.category = "Synonyms";
                this.generate = function(){
                    createWords(font, this.word, this.category);
                };
                this.reset = function(){
                    destroyWords();
                };
            };

            var settings = new FizzyText();
            var gui = new dat.GUI();

            gui.add(settings, 'word');
            gui.add(settings, 'category', [ 'Synonyms', 'Antonyms', 'Rhymes', 'Suggestions', 'SoundLike' ] );

            gui.add(settings, 'generate');

            gui.add(settings, 'reset');

            container = document.createElement( 'div' );
            document.body.appendChild( container );

            scene = new THREE.Scene();

            var ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            createWords(font, settings.word, settings.category);

            camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.set( 0, 100, 400 );
            
            renderer = new THREE.CanvasRenderer({ alpha: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            controls = new THREE.OrbitControls(camera,renderer.domElement);
            
            controls.enableDamping = true;
            controls.dampingFactor = .1;
            controls.rotateSpeed = .1;

            stats = new Stats();
            container.appendChild( stats.dom );

            window.addEventListener( 'resize', onWindowResize, false );

        }


        function createWords(font, word, category){
            var firstWordGeometry = new THREE.TextGeometry( word, {
                font: font,
                size: 20,
                height: 3,
                curveSegments: 1,
            });

            firstWordGeometry.computeBoundingBox();
            var centerOffset = -0.5 * ( firstWordGeometry.boundingBox.max.x - firstWordGeometry.boundingBox.min.x );

            var material = new THREE.MultiMaterial( [
                new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, overdraw: 0.5 } ),
                new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: 0.5 } )
            ] );

            if(numberOfGroup >= 3) {
                numberOfGroup = 0;
                destroyWords();
            }
            group = new THREE.Group();
            numberOfGroup++;
            
            var firstMesh = new THREE.Mesh( firstWordGeometry, material );

            firstMesh.position.x = 0;
            firstMesh.position.y = 0 - (numberOfGroup * 100);
            firstMesh.position.z = 0 + 5;

            firstMesh.rotation.x = 0;
            firstMesh.rotation.y = Math.PI * 2;

            if(category == "Synonyms")
                url = "https://api.datamuse.com/words?max=10&rel_syn=";
            else if(category == "Antonyms")
                url = "https://api.datamuse.com/words?max=10&rel_ant=";
            else if(category == "Suggestions")
                url = "https://api.datamuse.com/sug?max=10&s=";
            else if(category == "SoundLike")
                url = "https://api.datamuse.com/words?max=10&sl=";
            else   
                url = "https://api.datamuse.com/words?max=10&rel_rhy=";

            group.add( firstMesh );
            $.ajax({
                url: url + word,
                type: 'GET', 
                dataType: 'json',
                success: function(data) { 
                    for(var i = 0; i < data.length; i++)
                    {
                        if(data[i].score >= 10 &&  data[i].score < 150)
                            var fontSize = 7;
                        else if(data[i].score >= 150 &&  data[i].score < 500)
                            var fontSize = 9;                        
                        else if(data[i].score >= 500 &&  data[i].score <= 1000)
                            var fontSize = 10;
                        else if(data[i].score >= 1000 &&  data[i].score <= 2000)
                            var fontSize = 11;
                        else if(data[i].score > 2000)
                            var fontSize = 12;

                        var otherWordsGeometry = new THREE.TextGeometry( data[i].word, {
                            font: font,
                            size: fontSize,
                            height: 5, // Ã©paisseur 
                            curveSegments: 1
                        });

                        otherWordsGeometry.computeBoundingBox();

                        var mesh = new THREE.Mesh( otherWordsGeometry, material );
                        
                        if(i == 0){
                            mesh.position.x = firstMesh.position.x + (word.length * 20);
                            mesh.position.y = firstMesh.position.y + 5 * (i + 1);
                            mesh.position.z = firstMesh.position.z;   

                            var startPoint = new THREE.Vector3(firstMesh.position.x, firstMesh.position.y, firstMesh.position.z);
                            var endPoint   = new THREE.Vector3(mesh.position.x, mesh.position.y, mesh.position.z);
                            var direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
                            var arrow = new THREE.ArrowHelper(direction, startPoint, startPoint.distanceTo(endPoint), 0xCC0000 );
                            scene.add(arrow);

                        }
                        else{
                            mesh.position.x = previousMesh.position.x + (previousWord.length * 10);   
                            mesh.position.y = firstMesh.position.y + 5 * (i + 1);
                            mesh.position.z = firstMesh.position.z;     

                            var lineGeometry = new THREE.Geometry();
                            lineGeometry.vertices.push( new THREE.Vector3(previousMesh.position.x, previousMesh.position.y, previousMesh.position.z), new THREE.Vector3(mesh.position.x, mesh.position.y, mesh.position.z) );
                            lineGeometry.computeLineDistances();
                            var lineMaterial = new THREE.LineBasicMaterial( { color: 0xCCCCCC } );
                            var line = new THREE.Line( lineGeometry, lineMaterial );
                            scene.add(line);             
                        }

                        mesh.rotation.x = 0;
                        mesh.rotation.y = Math.PI * 2;

                        var previousMesh = mesh;
                        var previousWord = data[i].word;

                        group.add( mesh );
                    }
                },
                error: function(err) { 
                    alert(err); 
                }
            });

            scene.add( group );
        }

        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function destroyWords(){
            scene.children.slice().forEach(function(obj) { 
                console.log(scene.children);
                if(obj.type == "Group" || obj.type == "Line" || obj.type == "Object3D")
                    scene.remove(obj); 
            })
        }

        function animate() {

            requestAnimationFrame( animate );

            render();
            stats.update();

        }

        function render() {

            group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
            renderer.render( scene, camera );
        }

    </script>
</head>

<body>
</body>

</html>