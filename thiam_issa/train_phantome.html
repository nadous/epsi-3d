<!DOCTYPE html>
<html lang="en">
<!-- https://threejs.org/examples/#webgl_geometry_extrude_splines -->
<head>
   <!-- <script src="../../three.js-master/build/three.js"></script>

    <script src="../../three.js-master/examples/js/Detector.js"></script>
    <script src="../../three.js-master/examples/js/libs/stats.min.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>-->

     <script src="three.js-master/build/three.js"></script>
    <script src="three.js-master/examples/js/Detector.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script> 

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
        #bob_containerDiv {
            display: inline-block;
        }
    </style>

    <script>
        var lastPoint = null;
        var container, parent;
        var cylinder, scale;
        var camera, scene, projector, renderer, controls, stats;
		var splineCamera, cameraHelper, cameraEye;
        var lines = [];
        var isRotating = false;
        var z = 0;
        var speed = .01;
        var depthFactor = 250;
		// Variable pour la camera spline
		var animation = false, lookAhead = false;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		var binormal = new THREE.Vector3();
		var normal = new THREE.Vector3();
    
        function get3dPointZAxis(event) {
            var vector = new THREE.Vector3(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1,
                .5);
            z += speed;
            vector.unproject(camera);
            var dir = vector.sub(camera.position).normalize();
            var distance = -camera.position.z / dir.z;
            var pos = camera.position.clone().add(dir.multiplyScalar(distance));
            pos.setZ(Math.sin(z) * depthFactor);
            return pos;
        }
        function startDraw(event) {
            lastPoint = get3dPointZAxis(event);
        }
        function stopDraw(event) {
            lastPoint = null;
        }
        function doDraw(event) {
            if (lastPoint) {
                var pos = get3dPointZAxis(event);
                var material = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    linewidth: 5 // Pour voir l'Ã©paisseur de la ligne
                });
                var geometry = new THREE.Geometry();
                if (Math.abs(lastPoint.x - pos.x) < 500 && Math.abs(lastPoint.y - pos.y) < 500 && Math.abs(lastPoint.z - pos.z) < 500) {
                    geometry.vertices.push(lastPoint);
                    geometry.vertices.push(pos);
                    var line = new THREE.Line(geometry, material);
                    lines.push(line);
                    scene.add(line);
                    lastPoint = pos;
                } else {
                    console.debug(lastPoint.x.toString() + ':' + lastPoint.y.toString() + ':' + lastPoint.z.toString() + ':' +
                        pos.x.toString() + ':' + pos.y.toString() + ':' + pos.z.toString());
                }
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            init();
        });
        document.addEventListener('keypress', on_key_press);
        function on_key_press(e) {
            var key = e.which || e.keyCode;
            if (key === 13) { // 13 is enter
                document.removeEventListener('keypress', on_key_press);
                document.removeEventListener('mousedown', startDraw);
                document.removeEventListener('mouseup', stopDraw);
                document.removeEventListener('mousemove', doDraw);
                commit_lines();
                controls = new THREE.OrbitControls(camera); // Permet de controler les movements du cube par la souris
                controls.enableDamping = true;
                controls.dampingFactor = .1;
                controls.rotateSpeed = .1;
            }
        }
        function commit_lines() {
            isRotating = false;
            for (var i = 0; i < lines.length; i++) {
                var vertices = lines[i].geometry.vertices;
                cylinder = get_cylinder(vertices[0], vertices[1]);
                scene.add(cylinder);
            }
            /**/
        }
        
        function get_cylinder(pointX, pointY) {
            var mat = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                side: THREE.DoubleSide
            });
            var direction = new THREE.Vector3().subVectors(pointY, pointX);
            var orientation = new THREE.Matrix4();
            orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
            var comp = new THREE.Matrix4();
            orientation.multiply(comp.set(1, 0, 0, 0,
                0, 0, 1, 0,
                0, -1, 0, 0,
                0, 0, 0, 1));
            var edgeGeometry = new THREE.CylinderGeometry(20, 20, direction.length(), 8, 1, true);
            var edge = new THREE.Mesh(edgeGeometry, mat);
            edge.applyMatrix(orientation);
            // position based on midpoints - there may be a better solution than this
            edge.position.x = (pointY.x + pointX.x) / 2;
            edge.position.y = (pointY.y + pointX.y) / 2;
            edge.position.z = (pointY.z + pointX.z) / 2;
            return edge;
        }
		//Deplacement de la camera
		function animateCamera( toggle ) {
			if ( toggle === true ) {
				animation = animation === false;
				document.getElementById( 'animation' ).value = 'Camera Spline Animation View: ' + ( animation ? 'ON' : 'OFF' );
			}
			lookAhead = document.getElementById( 'lookAhead' ).checked;
			showCameraHelper = document.getElementById( 'cameraHelper' ).checked;
			cameraHelper.visible = showCameraHelper;
			cameraEye.visible = showCameraHelper;
		}
        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
			var info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'Train Phantome: Suivre une ligne';
			//info.innerHTML += dropdown;
			info.innerHTML += '<br/><br/><input id="animation" type="button" onclick="animateCamera(true)" value="Camera Spline Animation View: OFF"/><br/> Look Ahead <input id="lookAhead" type="checkbox" onchange="animateCamera()" /> Camera Helper <input id="cameraHelper" type="checkbox" onchange="animateCamera()" />';
			container.appendChild( info );
			
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 300, 500);
            scene = new THREE.Scene();
			//Add Code
			var light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 0, 0, 1 );
			scene.add( light );
			parent = new THREE.Object3D();
			scene.add( parent );
			splineCamera = new THREE.PerspectiveCamera( 84, window.innerWidth / window.innerHeight, 0.01, 1000 );
			parent.add( splineCamera );
			cameraHelper = new THREE.CameraHelper( splineCamera );
			scene.add( cameraHelper );
			//
            if (Detector.webgl)
                renderer = new THREE.WebGLRenderer({
                    antialias: true
                });
            else
                renderer = new THREE.CanvasRenderer();
            renderer.setClearColor(0xf0f0f0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            document.addEventListener('mousedown', startDraw, false);
            document.addEventListener('mouseup', stopDraw, false);
            document.addEventListener('mousemove', doDraw, false);
            //
			stats = new Stats();
			container.appendChild( stats.dom );
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        function onWindowResize() {
			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
        function animate() {
            requestAnimationFrame(animate);
            render();
			stats.update();
        }
        var radius = 1000;
        var theta = 90;
        function render() {
            if (isRotating) {
                theta += 0.1;
                camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
                camera.lookAt(scene.position);
            }
			// Try Animate Camera Along Spline
			for(var i = 0; i < lines.length; i += 0.5){
			var t = spline.getUtoTmapping(i / lines.length);
			var pos = cylinder.getPointAt(t);
			
}
			/*var time = Date.now();
			var looptime = 20 * 1000;
			var t = ( time % looptime ) / looptime;
			var pos = tube.parameters.path.getPointAt( t );*/
			pos.multiplyScalar( scale );
			// interpolation
			var segments = cylinder.tangents.length;
			var pickt = t * segments;
			var pick = Math.floor( pickt );
			var pickNext = ( pick + 1 ) % segments;
			binormal.subVectors( cylinder.binormals[ pickNext ], cylinder.binormals[ pick ] );
			binormal.multiplyScalar( pickt - pick ).add( cylinder.binormals[ pick ] );
			var dir = cylinder.parameters.path.getTangentAt( t );
			var offset = 15;
			normal.copy( binormal ).cross( dir );
			// We move on a offset on its binormal
			pos.add( normal.clone().multiplyScalar( offset ) );
			splineCamera.position.copy( pos );
			cameraEye.position.copy( pos );
			// Using arclength for stablization in look ahead.
			var lookAt = tube.parameters.path.getPointAt( ( t + 30 / tube.parameters.path.getLength() ) % 1 ).multiplyScalar( scale );
			// Camera Orientation 2 - up orientation via normal
			if ( !lookAhead ) lookAt.copy( pos ).add( dir );
			splineCamera.matrix.lookAt(splineCamera.position, lookAt, normal);
			splineCamera.rotation.setFromRotationMatrix( splineCamera.matrix, splineCamera.rotation.order );
			cameraHelper.update();
			renderer.render( scene, animation === true ? splineCamera : camera );
        }
    </script>
</head>

<body>

    <div style='display:block;position:absolute'>
        <!--<button onclick='addShapes();return false;'>Shapes</button>-->
        <button onclick='isRotating=true;return false;'>Rotate</button>
    </div>
</body>

</html>