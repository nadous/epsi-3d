<!DOCTYPE html>
<html lang="en">
<!-- https://threejs.org/examples/#webgl_geometry_extrude_splines -->

<head>
    <!--<script src="../../three.js-master/build/three.js"></script>

   <!-- <script src="../../three.js-master/examples/js/Detector.js"></script>
    <script src="../../three.js-master/examples/js/libs/stats.min.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script> -->

    <script src="three.js-master/build/three.js"></script>
    <script src="three.js-master/examples/js/Detector.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script>  

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
        #bob_containerDiv {
            display: inline-block;
        }
    </style>

    <script>
        const MODE_DRAW = 0;
        const MODE_TRAIN = 1;
        var mode = MODE_DRAW;
        var current_line_index = 0;
        var lastPoint = null;
        var container;
        var cylinder;
        var camera, scene, projector, renderer, stats;
        var lines = [];
        var isRotating = false;
        var z = 0;
        var speed = .001;
        var depthFactor = 150;
        var windowHalfX = window.innerWidth / 2,
            windowHalfY = window.innerHeight / 2;
		var sphereGeo, sphereMat, sphereMesh;
		var spherePoint, altitude, coeff;	
		var rad = 50;
      
		
		
		// Ecouteur d'événements
		document.addEventListener('DOMContentLoaded', function() {
            init();
        });
		document.addEventListener('keypress', on_key_press);
		
		///// Functions used for drawing the line
        function get3dPointZAxis(event) {
            var vector = new THREE.Vector3(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1,
                .5);
            z += speed;
            vector.unproject(camera);
            var dir = vector.sub(camera.position).normalize();
            var distance = -camera.position.z / dir.z;
            var pos = camera.position.clone().add(dir.multiplyScalar(distance));
            pos.setZ(Math.sin(z) * depthFactor);
            return pos;
        }
        function startDraw(event) {
            lastPoint = get3dPointZAxis(event);
        }
        function stopDraw(event) {
            lastPoint = null;
        }
        function doDraw(event) {
            if (lastPoint) {
                var pos = get3dPointZAxis(event);
                var material = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    linewidth: 5 // Pour voir l'épaisseur de la ligne
                });
                var geometry = new THREE.Geometry();
                if (Math.abs(lastPoint.x - pos.x) < 500 && Math.abs(lastPoint.y - pos.y) < 500 && Math.abs(lastPoint.z - pos.z) < 500) {
                    geometry.vertices.push(lastPoint);
                    geometry.vertices.push(pos);
                    var line = new THREE.Line(geometry, material);
                    lines.push(line);
                    scene.add(line);
                    lastPoint = pos;
                } else {
                    console.debug(lastPoint.x.toString() + ':' + lastPoint.y.toString() + ':' + lastPoint.z.toString() + ':' +
                        pos.x.toString() + ':' + pos.y.toString() + ':' + pos.z.toString());
                }
            }
        }
		
        // This function allow to create the cylinder by
		// pressing the Enter Key
        
		
        function on_key_press(e) {
            var key = e.which || e.keyCode;
            if (key === 13) { // 13 is enter
                document.removeEventListener('keypress', on_key_press);
                document.removeEventListener('mousedown', startDraw);
                document.removeEventListener('mouseup', stopDraw);
                document.removeEventListener('mousemove', doDraw);
                commit_lines();
                // controls = new THREE.OrbitControls(camera); // Permet de controler les movements du cube par la souris
                // controls.enableDamping = true;
                // controls.dampingFactor = .1;
                // controls.rotateSpeed = .1;
            }
        }
		// this function create the cylinder througth the lines array
        function commit_lines() {
            isRotating = false;
			
            for (var i = 0; i < lines.length; i++) {
                var vertices = lines[i].geometry.vertices;
                cylinder = get_cylinder(vertices[0], vertices[1]);
                scene.add(cylinder);
            }
			// On ajoute une sphere qui prend le trajectoire de la ligne
			
					sphereGeo = new THREE.SphereGeometry( rad, 16, 12 );
					sphereMat = new THREE.MeshNormalMaterial();

					sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
					
					scene.add(sphereMesh);
            mode = MODE_TRAIN;
        }
		
		// THe function return the cylinderGeometry
        function get_cylinder(pointX, pointY) {
            var mat = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                side: THREE.DoubleSide
            });
            var direction = new THREE.Vector3().subVectors(pointY, pointX);
            var orientation = new THREE.Matrix4();
            orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
            var comp = new THREE.Matrix4();
            orientation.multiply(comp.set(1, 0, 0, 0,
                0, 0, 1, 0,
                0, -1, 0, 0,
                0, 0, 0, 1));
            var edgeGeometry = new THREE.CylinderGeometry(20, 20, direction.length(), 8, 1, true);
            var edge = new THREE.Mesh(edgeGeometry, mat);
            edge.applyMatrix(orientation);
            edge.position.x = (pointY.x + pointX.x) / 2;
            edge.position.y = (pointY.y + pointX.y) / 2;
            edge.position.z = (pointY.z + pointX.z) / 2;
            return edge;
        }
    
        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            var info = document.createElement('div');
            info.style.position = 'absolute';
            info.style.top = '10px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.innerHTML = 'Train Fantome: Follow the Track';
            container.appendChild(info);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 300, 500);
            scene = new THREE.Scene();
            //Add Code
            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, 0, 1);
            scene.add(light);
			
			

			altitude = 100;

			coeff = 1+ altitude/rad;

            //
            if (Detector.webgl)
                renderer = new THREE.WebGLRenderer({
                    antialias: true
                });
            else
                renderer = new THREE.CanvasRenderer();
            renderer.setClearColor(0xf0f0f0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            document.addEventListener('mousedown', startDraw, false);
            document.addEventListener('mouseup', stopDraw, false);
            document.addEventListener('mousemove', doDraw, false);
            //
            stats = new Stats();
            container.appendChild(stats.dom);
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
		
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            render();
            stats.update();
        }
        var radius = 1000;
        var theta = 90;
        function render() {
            if (isRotating) {
                theta += 0.1;
                camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
                camera.lookAt(scene.position);
            }
            if (mode === MODE_TRAIN) {
				
                if (current_line_index >= lines.length - 1)
                    current_line_index = 0;

				var vertices = lines[current_line_index].geometry.vertices;	
                var cam_position = vertices[0];
                sphereMesh.position.set(cam_position.x, cam_position.y, cam_position.z);
				
				var vertices1 = lines[current_line_index + 10].geometry.vertices;	
                var lookat_position = vertices1[0];
                //camera.lookAt(sphereMesh.position);
				camera.lookAt(camera.position);
                current_line_index++;
            }
            renderer.render(scene, camera);
        }
    </script>
</head>

<body>

    <div style='display:block;position:absolute'>
        <!--<button onclick='addShapes();return false;'>Shapes</button>-->
        <button onclick='isRotating=true;return false;'>Rotate</button>
    </div>
</body>

</html>