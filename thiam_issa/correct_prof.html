<!DOCTYPE html>
<html lang="en">
<!-- https://threejs.org/examples/#webgl_geometry_extrude_splines -->
<head>
    <script src="../../three.js-master/build/three.js"></script>

    <script src="../../three.js-master/examples/js/Detector.js"></script>
    <script src="../../three.js-master/examples/js/libs/stats.min.js"></script>
    <script src="../../three.js-master/examples/js/controls/OrbitControls.js"></script>

    <!-- <script src="three.js-master/build/three.js"></script>
    <script src="three.js-master/examples/js/Detector.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>
	<script src="three.js-master/examples/js/controls/OrbitControls.js"></script> -->

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }

        #bob_containerDiv {
            display: inline-block;
        }
    </style>

    <script>
        var lastPoint = null;
        var container;
        var cylinder;
        var camera, scene, projector, renderer, controls;
        var lines = [];
        var isRotating = false;
        var z = 0;
        var speed = .01;
        var depthFactor = 250;
        var getCylinder = false;

        function get3dPointZAxis(event) {
            var vector = new THREE.Vector3(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1,
                .5);
            z += speed;
            vector.unproject(camera);
            var dir = vector.sub(camera.position).normalize();
            var distance = -camera.position.z / dir.z;
            var pos = camera.position.clone().add(dir.multiplyScalar(distance));
            pos.setZ(Math.sin(z) * depthFactor);
            return pos;
        }

        function startDraw(event) {
            lastPoint = get3dPointZAxis(event);
        }

        function stopDraw(event) {
            lastPoint = null;
        }

        function doDraw(event) {
            if (lastPoint) {
                var pos = get3dPointZAxis(event);
                var material = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    linewidth: 5 // Pour voir l'Ã©paisseur de la ligne
                });
                var geometry = new THREE.Geometry();
                if (Math.abs(lastPoint.x - pos.x) < 500 && Math.abs(lastPoint.y - pos.y) < 500 && Math.abs(lastPoint.z - pos.z) < 500) {
                    geometry.vertices.push(lastPoint);
                    geometry.vertices.push(pos);
                    var line = new THREE.Line(geometry, material);
                    lines.push(line);
                    scene.add(line);
                    lastPoint = pos;
                } else {
                    console.debug(lastPoint.x.toString() + ':' + lastPoint.y.toString() + ':' + lastPoint.z.toString() + ':' +
                        pos.x.toString() + ':' + pos.y.toString() + ':' + pos.z.toString());
                }
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            init();
        });

        document.addEventListener('keypress', on_key_press);

        function on_key_press(e) {
            var key = e.which || e.keyCode;
            if (key === 13) { // 13 is enter
                document.removeEventListener('keypress', on_key_press);
                document.removeEventListener('mousedown', startDraw);
                document.removeEventListener('mouseup', stopDraw);
                document.removeEventListener('mousemove', doDraw);
                commit_lines();
                controls = new THREE.OrbitControls(camera); // Permet de controler les movements du cube par la souris
                controls.enableDamping = true;
                controls.dampingFactor = .1;
                controls.rotateSpeed = .1;
            }
        }

        function commit_lines() {
            isRotating = false;
            for (var i = 0; i < lines.length; i++) {
                var vertices = lines[i].geometry.vertices;
                cylinder = get_cylinder(vertices[0], vertices[1]);
                scene.add(cylinder);
            }
            /**/
        }
        /*function get_cylinder(v1, v2) {
            // edge from X to Y
            var direction = new THREE.Vector3().subVectors(v1, v2);
            var arrow = new THREE.ArrowHelper(direction.clone().normalize(), v1, 100, 0xff0000);
            // cylinder: radiusAtTop, radiusAtBottom,
            //     height, radiusSegments, heightSegments
            var edgeGeometry = new THREE.CylinderGeometry(20, 20, direction.length(), 12, 4);
            var edge = new THREE.Mesh(
                edgeGeometry,
                new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    wireframe: true
                }));
            var position = new THREE.Vector3().addVectors(v1, direction.multiplyScalar(0.5));
            // trouve comment appliquer correctement la rotation
            edge.rotation = arrow.rotation.clone();
            edge.position.set(position.x, position.y, position.z);
            scene.add(arrow);
            // console.log(new THREE.Vector3().add(v1));
            // edge.position = new THREE.Vector3().addVectors(v1, direction.multiplyScalar(0.5));
            return edge;
        }*/

        function get_cylinder(pointX, pointY) {
            var mat = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                side: THREE.DoubleSide
            });
            var direction = new THREE.Vector3().subVectors(pointY, pointX);
            var orientation = new THREE.Matrix4();
            orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
            var comp = new THREE.Matrix4();
            orientation.multiply(comp.set(1, 0, 0, 0,
                0, 0, 1, 0,
                0, -1, 0, 0,
                0, 0, 0, 1));
            var edgeGeometry = new THREE.CylinderGeometry(20, 20, direction.length(), 8, 1, true);
            var edge = new THREE.Mesh(edgeGeometry, mat);
            edge.applyMatrix(orientation);
            // position based on midpoints - there may be a better solution than this
            edge.position.x = (pointY.x + pointX.x) / 2;
            edge.position.y = (pointY.y + pointX.y) / 2;
            edge.position.z = (pointY.z + pointX.z) / 2;
            return edge;
        }

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 300, 500);
            scene = new THREE.Scene();

            if (Detector.webgl)
                renderer = new THREE.WebGLRenderer({
                    antialias: true
                });
            else
                renderer = new THREE.CanvasRenderer();
            renderer.setClearColor(0xf0f0f0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            document.addEventListener('mousedown', startDraw, false);
            document.addEventListener('mouseup', stopDraw, false);
            document.addEventListener('mousemove', doDraw, false);

            //
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }
        var radius = 1000;
        var theta = 90;

        function render() {
            if (isRotating) {
                theta += 0.1;
                camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
                camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
                camera.lookAt(scene.position);
            }
            renderer.render(scene, camera);
        }
    </script>
</head>

<body>

    <div style='display:block;position:absolute'>
        <!--<button onclick='addShapes();return false;'>Shapes</button>-->
        <button onclick='isRotating=true;background=green;return false;'>Rotate</button>
    </div>
</body>

</html>
